
## DEBUG 的主要用途及 DEBUG 的调用
```
DEBUG 是为汇编语言设计的一种调试工具，它通过单步执行、设置断点等方式为汇编语言程序员提供了非常有效的程序调试手段DEBUG 可以直接用来检查和修改内存单元、装入、存储及启动运行程序、检查及修改寄存器，也就是说 DEBUG 可深入到计算机的内部，可使用户更紧密地与计算 机中真正进行的工作相联系。在 DEBUG 下运行汇编语言源 程序也受到了一些限制，它不宜汇编较长的程序，不便于分块程序设计，不便于形成以 DOS 外部命 令形式构成的 .EXE 文件，不能使用浮动地址，也不能使用 ASM 和 MASM 提供的绝大多数伪指令。
在 DOS 系统中，DEBUG 是以 DOS 外部命令文件形式提供给用户的，名为 DEBUG.EXE。
进入 DEBUG 的提示符是符号“-”。即，出现提示符“-”就表示可以接受 DEBUG 命令了。 当进入 DEBUG 时，寄存器和标志设成以下数值，这些值用于 DEBUG 调试中的程序。
段寄存器 CS，DS，ES 和 SS 均指向 DEBUG 末尾的第一个段。
IP 寄存器置为 0100H。栈指针 SP 指向尾部或装入程序的暂存部分的底部。 其余寄存器皆取零值，但若用户调用时含文件说明，则 CX 含文件长度(长度大于 64K 时 BX 含
长度的高位);标志为各自的复位值;驱动器传送地址在代码段位移 80H 处。
注意:若 DEBUG 装入扩展名为.EXE 的文件，则 DEBUG 需重定位且设置段寄存器指示器为文件中
所定义的值。但 DS，ES 指向最低可用段处的程序区前缀。BX 和 CX 为文件容量值。而 .EXE 文件如 果在连接时选择了装入内存高处的参数，则该程序装入高处。
```

## DEBUG 的主要命令功能与格式
```
DEBUG 命令是在 DEBUG 提示符“-”下，由键盘键入的。每条命令以单个字母的命令符开头，然后是命令的操作参数，操作参数与操作参数之间，用空格或逗号隔开，操作参数与命令符之间用空 格隔开，命令的结束符是回车键 Enter。命令及参数的输入可以是大小写的结合。Ctrl+Break 键可 中止命令的执行。Ctrl+Num Lock 键可暂停屏幕卷动，按任一键继续。所用数均为十六进制数，且 不必写 H。
```
### 汇编命令 A
```
格式: A [[<段寄存器名>/<段地址>:] <段内偏移>]
    上式等价于:
    (1) A <段寄存器名>:<段内偏移>
    (2) A <段地址>:<段内偏移>
    (3) A <段内偏移>
    (4) A

功能: 键入该命令后显示段地址和段内偏移并等待用户从键盘逐条键入汇编命令，逐条汇编成代码指令，顺序存放到段地址和段内偏移所指定的内存区域，直到显示下一地址时用户直接键入回车键 返回到提示符“-”。

注: 其中(1)用指定段寄存器的内容作段地址，(3)用 CS 的内容作段地址，(4)以 CS:100 作地址。以 后命令中提及的各种‘地址’形式，均指(1)、(2)、(3)中 A 后的地址形式。
```

### 比较命令 C
```
格式: C <源地址范围>，<目标地址>
    其中<范围>是由<起始地址> <终止地址>或者是由<起始地址> L <长度>指出的一片连续单元。 

功能: 从<源地址范围>的起始地址单元起逐个与目标起始地址以后的单元顺序比较单元的内容，直至源终止地址为止。遇有不一致时，以<源地址> <源内容> <目标内容> <目标地址>的形式显示失配单元及内容。
```

### 显示内存命令 D
```
格式: D [<地址>/<范围>]
    上式等价于:
    (1) D <地址>
    (2) D <范围>
    (3) D

功能: 以两种形式显示指定范围的内存内容。一种形式为十六进制内容，一种形式为以相应字节的 内容作为 ASCII 码的字符，对不可见字符以‘.’代替。

注: 其中(1)以 CS 为段寄存器。(3)显示 CS:100 起始的一片内容。
```

### 修改内存命令 E
```
格式: E <地址> [<单元内容表>] 上式等价于:
    (1) E <地址>
    (2) E <地址> <单元内容表>
    其中<单元内容表>是以逗号分隔的十六进制数，或用’或”括起来的字符串，或者是二者的组合。

功能: (1)不断显示地址，可连续键入修改内容，直至新地址出现后键入回车 Enter 为止。(2)将< 单元内容表>逐一写入由<地址>开始的一片单元。
```

### 填充内存命令 F
```
格式: F <范围> <单元内容表>

功能: 将单元内容表中的值逐个填入指定范围，单元内容表中内容用完后重复使用。

例如: -F 5BC:200 L 10 B2，‘XYZ’，3C <Enter>
```

### 执行命令 G
```
格式: G [=<地址>[，<断点>]]

功能: 执行内存中的指令序列

注:
    (1)从 CS:IP 所指处开始执行
    (2)从指定地址开始执行
    (3)从指定地址开始执行，到断点自动停止。
```

### 读盘命令 L
```
格式: L <地址> <驱动器号> <起始逻辑扇区> <所读扇区个数 n>
其中<地址>的缺省值为 CS:100。逻辑扇区可由物理扇区号换算得到，以双面双密度盘为例:物理扇区是按0面0道1区，0 面 0 道 2 区，......，0 面 0道 9 区，0 面 1 道 1 区，......，0 面 39 道 9 区，1 面 0 道 1 区，......，1 面 39 道 9 区排列。而逻辑扇区与物理扇区号的对应关系为物理扇区 0 面 0 道 1 扇区至 9 扇区，逻辑扇区号 0 — 8 ;物理扇区1面0道1扇区至9扇区，逻辑扇区号为 9 —11H;物理扇区 0 面 1 道 1 扇区至 9 扇区，逻辑扇区号 12—1AH;......。这样每道先 0 面后 1 面 一直排下去。其中<驱动器号>为 0、1 或 2，0 表示 A 驱，1 表示 B 驱，2 表示硬盘。

功能: 将<驱动器号>指定的盘上，从<起始逻辑扇区>起，共 n 个逻辑扇区上的所有字节顺序读入指 定内存地址开始的一片连续单元。当 L 后的参数缺省时，必须在 L 之前由 N 命令指定(或进入 DEBUG 时一并指出)所读驱动器文件名。此时 L 执行后将该文件装入内存。

例如: -N EXAMPLE <Enter> -L <Enter>
将当前驱动器上的 EXAMPLE 文件装入 CS:100 起始的一片内存单元。
```

### 命名待读/写文件命令 N
```
格式: N <文件名说明>

功能: 为 L/W 命令指定待装入/写盘文件

注: 其它形式参考 DOS 手册
```

### 端口输出命令 O
```
格式: O <端口地址> <字节>

功能: 将该<字节>从指定<端口地址>输出。

例如: -O 2F 4F <Enter>
将4FH从端口2FH输出
```

### 结束DEBUG返回DOS命令 Q
```
格式:Q

功能:返回 DOS 提示符下
```

### 显示修改寄存器命令 R
```
格式: R [<寄存器名>]
    上式等价于:
    (1) R
    (2) R <寄存器名>

功能:
(1)显示当前所有寄存器内容，状态标志及将要执行的下一指令的地址，代码及汇编语句形式。 其中对状态标志 FLAG 以每位的形式显示，详见表 1-1。
| 标志位 | 溢出 OF | 方向 DF | 中断 IF | 符号 SF | 零 ZF | 辅助 AF | 奇偶 PF | 进位 CF |
|----------|:-------------:|:-------------:|:-------------:|:-------------:|:-------------:|:-------------:|:-------------:|------:|
| 状态 | 有/无 | 减/增 | 开/关 | 负/正 | 零/非 | 有/无 | 偶/奇 | 有/无 |
| 显示 | OV/NV | DN/UP | EI/DI | NG/PL | ZR/NZ | AC/NA | PE/PO | CY/NC |

(2)显示指定寄存器内容
例如:
    -R AX <Enter>
    -R F <Enter>
```

### 跟踪命令T
```
格式: T [=<地址>] [<条数>] 功能:执行由指定地址起始的、由<条数>指定的若干条命令。其中<地址>的缺省值是当前 IP 值，< 条数>的缺省值是一条。

例如:
    -T <Enter>      执行当前指令并显示状态
    -T 10 <Enter>   从当前指令始执行 10H 条指令
```

### 反汇编命令 U
```
格式: U [<地址>/<地址范围>]
    上式等价于:
    (1) U <地址>
    (2) U <地址范围>
    (3) U

功能: 将指定范围内的代码以汇编语句形式显示，同时显示地址及代码。注意，反汇编时一定确认 指令的起始地址后再作，否则将得不到正确结果。地址及范围的缺省值是上次 U 指令后下一地址的 值。这样可以连续反汇编。
```

### 写盘命令W
```
格式: W <地址> <盘号> <起始逻辑扇区> <所写逻辑扇区数 n>

功能: 与 L 命令不同的地方是将内存从<地址>起始的一片单元内容写入指定扇区。只有 W 而没有参 数时，与 N 命令配合使用将文件写盘。

注: 要求读者对其中打"*"的 DEBUG 命令必须能熟练使用。
```

## 使用 DEBUG 调试和运行可执行文件
```
1.调用 DEBUG，装入用户程序
可以在调用 DEBUG 是直接装入用户程序可执行文件，也可以在进入 DEBUG 环境后使用 N 命令和 L 命令装入用户程序可执行文件。无论用哪种方法，装入用户程序可执行文件时，一定要指定文件 全名(即文件名和扩展名)。

2.观察寄存器初始状态
程序装入内存后，用 R 命令查看寄存器内容。从各段寄存器现在的内容，便能了解用户程序各 逻辑段(代码段，堆栈段等)在内存的分布及其段基值。R 命令亦显示了各通用寄存器和标志寄存 器的初始值，显示的第三行就是即将执行的第一条指令。

3.以单步工作方式开始运行程序
首先用 T 命令顺序执行用户程序的前几条指令，直到段寄存器 DS 和/或 ES 已预置为用户的数 据段。在用 T 命令执行程序时，每执行一条指令，显示指令执行后寄存器的变化情况，以便用户查 看指令执行结果。

4.观察用户程序数据段初始内容
在第 3 步执行后 DS 和/或 ES 已指向用户程序的数据段和附加段，这时用 D 命令可查看用户程 序的原始数据。

5.继续以单步工作方式运行程序
对于初学者，一般编写的程序比较短，用 T 命令逐条执行指令，可清楚地了解程序的执行过程: 现在执行的是什么指令，执行后的结果在哪里(寄存器，存储单元)?所得结果是否正确?等等。 在逐次使用 T 命令时，若有需要，可选用 D 命令了解某些内存单元的变化情况。用 T 命令逐条执行程序时，如遇上用户程序中的软中断指令 INT(如INT 21H)，这时，通常不 要用单步工作方式执行 INT 指令。因为系统提供的软中断指令 INT 是以中断处理子程序形式实现功 能调用，且这种处理子程序常常是较长的。若用 T 命令去执行 INT 指令，那么将跳转到相应的功能 调用于程序中，要退出该子程序需要化费较多时间。如果既要执行 INT 指令，又要跳过这段功能调 用子程序，则应使用连续工作方式(G 命令)，且设置断点，其断点应为 INT 指令的下一条指令。例 如要以单步工作方式执行下面一段程序:
    10B0:0022   MOV DX，0010
    10B0:0026   MOV AH，09
    10B0:0028   INT 21
    10B0:002A   MOV CX，00
    当用 T 命令完成“MOV AH，09”指令后，应使用 G 命令:
    -G 002A <Enter>
    这样，以连续工作方式实现功能调用后，即暂停在偏移量为 002A 的“MOV CX，00”指令处(未 执行)，如同用单步工作方式完成 INT 指令的执行一样。

6.连续工作方式运行程序
在用单步工作方式运行程序后，可再用连续工作方式从头开始运行程序，查看运行结果。在用G 命令时，注意指定运行程序的起始地址。若 G 命令中未指定起始地址，就隐含为从当前 CS:IP 指 向的指令开始。

7.修改程序和数据
经过上面几步后，若发现程序有错，则需要适当进行修改。这时，如果仅需作个别修改，可在 DEBUG 状态下，使用 A 命令。这种修改仅仅是临时修改内存中的可执行文件，未涉及源程序。当 确认修改正确后，应返回至编辑程序，修改源程序，然后再汇编、连接。
为了确认用户程序的正确性，常常需用几组不同的原始数据去运行程序，查看是否都能获得正 确结果。这时，可用 E 命令在用户程序的数据段和附加段中修改原始数据，然后再用 T 命令或 G 命 令运行程序，查看运行结果，直到各组数据都能获得正确结果为止。

8.运用断点调试程序
如果已确认程序是正确的，在连续工作方式下，可快速地运行程序;如果已知程序运行结果不 正确，用 G 命令运行程序，中途不停，很难查找错误。改用 T 命令，虽然可以随意暂停程序的执行， 但是运行速度慢，如果运用断点，可快速查找错误。这里的“断点”是程序连续运行时要求暂停的 指令位置(地址)，用要求暂停的一条指令首字节地址表示。当程序连续运行到这断点地址时，程序 就暂停，并显示现在各寄存器内容和下面将要执行的指令(即断点处指令)。为了准确设置断点，可 用反汇编命令 U 察看源程序。运用断点，可以很快地查找出错误发生在哪一个程序段内，缩小查找 错误的范围。然后在预计出错的范围内，再用 T 命令仔细观察程序运行情况，确定出错原因和位置， 完成程序的调试。
```
